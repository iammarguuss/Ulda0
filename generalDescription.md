# 0am

> This document describes the workings of the Ulda0 algorithm and the 0am method for Oleksandr Strakh, PhD.

## 1. Опис методу

### Основні принципи 
Цей метод ґрунтується на ітеративному доказі попереднього кроку. Тобто щоразу користувач доводить серверу, що з попередньому зверненні це був той самий користувач.
Ідея ґрунтується на ідеї того, що потрібно якось проводити умовну автентифікацію в контексті високої недовіри. Сервер не може довіряти клієнту і не може зберігати секретів (наприклад, якщо база даних публічна).

### Процес аутентифікації: 
Процес аутентифікації розрахований на перевірки автентичності запиту, щоб переконатися у приналежності до джерела (наприклад користувача або розділу).

Для покращення читабельності, наступний опис було зроблено за допомогою gpt:
#### Математична модель верифікації
1. **Визначення функції хешування:**
	- Нехай $f(x)$ — це функція хешування, де $x$ — вхідний рядок
	- Функція $f$ перетворює $x$ у хеш $h$, так що $h=f(x)$.
2. **Визначення процесу ітерації:**
	- У кожній ітерації $i$, користувач генерує новий рядок $x_{i+1}$ та відповідний хеш $h_{i+1}​=f(x_{i+1}​)$ .
	- Користувач надсилає $x_i$​ та $h_{i+1}$​ на сервер.
3. **Перевірка хешу на сервері:**
	- Сервер перевіряє, що $h_i = f(x_i)$.
	- Якщо перевірка успішна, сервер оновлює збережений хеш на новий $h_{i+1}$.
	- Якщо перевірка успішна, сервер вважає валідацію успішною та виконує запит користувача 

### Безпека:
Такий метод дозволяє гарантувати підтвердження права володіння попереднім запитом. Або якщо ми говоримо про контекст зміни або проведення операції над умовним об'єктом на сервері – цей метод зможе гарантувати володіння цим об'єктом.

#### Переваги
**Відсутність ключа у клієнта** - Клієнту не обов'язково зберігати ключ безпеки, оскільки ключ буде оновлюватися з кожним запитом
**"Анонімний клієнт"** - клієнт при зверненні до сервера може бути не ідентифікованим, поки сервер отримує новий запит разом із новим хешом та текстом.
**Потенційна відмова від api** - при використанні цього методу. Якщо ключ може бути вкрадений або втрачений, то при початку роботи в режимі клієнт-сервер (сервер-провайдер сервісу і сервер споживач) програміст або просто власник ключа вже не повинен буде втратити актуальну його версію
#### Недоліки
Потенційна вразливість до **MITM** - описаний метод буде надмірно вразливим до таких атак, проте якщо ми додамо рівні ітеративності (буде описано нижче) і ми будемо використовувати його в контексті https трафіку, він повинен бути цілком стійким.
#### Складності реалізації
Дане рішення може бути досить важко застосовним, оскільки для його використання необхідна низка змін логіки щодо конвенційних систем валідації.


## 2. Оптимізація для реального використання
### Створення відмовостійкості
Якщо враховувати особливості реального світу, наприклад, якщо пакет може не дійти або перехопити, алгоритм не може використовувати у вихідному форматі. Для адаптації нашого методу, нам необхідно усунути сценарій, коли пакет дійде до сервера. У разі пакета, що не йшов, потрібно мати можливість не втратити ланцюжок змін і втратити можливість виконувати оновлення.
#### Опис алгоритму
Зміна алгоритму полягає в тому, щоб додати кілька ітерацій підпису, працюватимуть таким же чином, проте хіба що нашаровуватись один на одного.
Алгоритм підписів мовою js описаний у ulda.js у функції generateLinkedHashes.
Опис для покращення читаності написано gpt 4:
##### Формула ітеративного хешування
Для кожного рівня $i$ від $1$ до $n$, хеш $H$ на рівні $i$ визначається як:
$H(i, j) = \text{hash}(H(i-1, j), H(i-1, j+1))$
де:
- $H(i, j)$ - хеш на рівні $i$ і позиції $j$,
- $\text{hash}$ - хеш-функція, наприклад, SHA-256,
- $H(i−1,j)$ та $H(i-1, j+1)$ — попередні хеші з попереднього рівня.
##### Кінцевий результат:
$H_{\text{final}} = H(n, 1)$
Ця формула показує, як кожен новий хеш на рівні $i$ залежить від двох попередніх хешів на рівні $i-1$, Хешування починається з базового рівня $i = 0$ з початкового набору даних і продовжується до рівня $n$, де залишається лише один хеш. Це ітеративний процес поступово скорочує кількість хешів, доки досягне єдиного кінцевого хеша $H_{\text{final}}$ , який є результатом всього процесу хешування.
#### Переваги такого методу
Переваги такого методу полягають переважно у підвищенні надійністю протоколу доставки. Тобто, якщо запит з новим підписом не був доставлений на сервер, ми можемо видати новий запит з новим, нескомпрометованим підписом.
#### Недоліки такого методу
Надлишкове споживання пам'яті - він стосується як транспортних витрат, і зберігання, оскільки за сервера необхідно зберігати $n$ підписів $2n$ підписів за відправляє запити. Так само при пересиланні необхідно відправити $2n$ підписів для здійснення запитів (проте якщо точно відомо, що сервер має нову версію підпису достатньо відправляти $n$ підписів, як і використовується в моїй реалізації).

Надмірна кількість раундів хешування. Для довжини $n$ підписів необхідно провести $S=n(n+1)/2$ раундів хешування, що може бути надмірно для деяких систем. Однак це не проблема.
#### Допущення (сподіватися, що https безпечний)
Цей метод може працювати в контексті https або будь-якого іншого захищеного протоколу.
#### Доповнення відмовостійкості у контексті використання  
У контексті роботи 0am (він буде описаний далі), передбачена "корекція помилок", яка дозволяє відновити доступ у тому випадку, якщо всі підписи будуть скомпрометовані, ми створюємо додатковий контур підписів з більш складним алгоритмом (наприклад, bcrypt з високою складністю) і не обов'язково , щоб він мав кілька підписів. 


## 3. Реалізація та застосування на прикладі проекту
### Опис проекту на основі 0am
#### Опис продукту
Ця бібліотека **0 authentification managemnt** system (0am) розрахована на спрощення використання файлами без автентифікації у звичному форматі.
Ідея в тому, щоб на стороні розробника мати можливість безшовного використання бібліотеки за допомогою json об'єкта з даними користувача розкладених по головних і контентних файлах (буде описано далі).
Однією з головних прикладів використання я бачу в кабінеті користувача, або частини кабінету, який повинен бути використаний на стороні користувача, однак повинен бути безпечно збережений.
Приклад використання з боку розробника має виглядати так:
```js
ПримірникКласу.Ім$яКонтентФайлу.об$єкт.об$єкт;
//or
ulda.user.profile.name;
```
На мою думку такий формат має бути легко зрозумілим розробнику і має порівняно класичну логіку ($login=>profile$) і порівняно бути порівняно інтегрованим у існуючі системи.

P.S. ідеологічно цей проект швидше схожий на mongodb, тільки замість запитів ми використовуємо звернення до json об'єкту, який стягується та оновлюється в автоматичному режимі.
#### Плюси 0am
Головна ідея 0am - це максимальне спрощення підходу який дозволяє не зберігати дані своїх користувачів. (Контекст 0am полягає в тому, що це хмарне рішення, проте воно може так само хоститься біля самого сервісу).
**Масштабованість** - оскільки така система розрахована на реляційну базу даних (наприклад, postgres), вона може порівняно легко масштабуватися. Однак система зберігання з логічним індексуванням буде добре працювати на mongodb або будь-якій іншій нереляційній базі даних.
**Ієрархія файлів** - для підвищення надійності самої системи, ми орієнтуємося на підхід зберігання паролів, де файли поділяються на 2 типи - **Майстер** файли та **Контент** файли. Майстер файли використовується для зберігання паролів та місцезнаходження (індекси) Контент файлів. А саме, користувач використовує один пароль (пропущений, наприклад, через алгоритм pbkdf). При цьому в майстер-файлі зберігаються вже криптографічно-сильні паролі (З ентропією $e>200$). Також, такий підхід заозоляє помітно знизити звернення та переписування підписів до найбільш чутливому об'єкту.
#### Недоліки 0am
Без реального використання такого продукту, досить складно оцінити недоліки такого рішення, крім ресурсомісткості такого рішення.
### Файловий сервер як логічний додаток 0am для роботи з файлами
Я не впевнений, що є сенс серйозно обговорювати файловий сервер на цій технології, якщо його надійність все ще залишається під питанням.