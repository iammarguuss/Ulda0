# 0am

> This document describes the workings of the Ulda0 algorithm and the 0am method for Oleksandr Strakh, PhD.

### 1. Опис методу

##### Основні принципи 
Цей метод ґрунтується на ітеративному доказі попереднього кроку. Тобто щоразу користувач доводить серверу, що з попередньому зверненні це був той самий користувач.
Ідея ґрунтується на ідеї того, що потрібно якось проводити умовну автентифікацію в контексті високої недовіри. Сервер не може довіряти клієнту і не може зберігати секретів (наприклад, якщо база даних публічна).

##### Процес аутентифікації: 
Процес аутентифікації розрахований на перевірки автентичності запиту, щоб переконатися у приналежності до джерела (наприклад користувача або розділу).

Для покращення читабельності, наступний опис було зроблено за допомогою gpt:
###### Математична модель верифікації
1. **Визначення функції хешування:**
	- Нехай $f(x)$ — це функція хешування, де $x$ — вхідний рядок
	- Функція $f$ перетворює $x$ у хеш $h$, так що $h=f(x)$.
2. **Визначення процесу ітерації:**
	- У кожній ітерації $i$, користувач генерує новий рядок $x_{i+1}$ та відповідний хеш $h_{i+1}​=f(x_{i+1}​)$ .
	- Користувач надсилає $x_i$​ та $h_{i+1}$​ на сервер.
3. **Перевірка хешу на сервері:**
	- Сервер перевіряє, що $h_i = f(x_i)$.
	- Якщо перевірка успішна, сервер оновлює збережений хеш на новий $h_{i+1}$.
	- Якщо перевірка успішна, сервер вважає валідацію успішною та виконує запит користувача 

##### Безпека:
Такий метод дозволяє гарантувати підтвердження права володіння попереднім запитом. Або якщо ми говоримо про контекст зміни або проведення операції над умовним об'єктом на сервері – цей метод зможе гарантувати володіння цим об'єктом.

###### Переваги
**Відсутність ключа у клієнта** - Клієнту не обов'язково зберігати ключ безпеки, оскільки ключ буде оновлюватися з кожним запитом
**"Анонімний клієнт"** - клієнт при зверненні до сервера може бути не ідентифікованим, поки сервер отримує новий запит разом із новим хешом та текстом.
**Потенційна відмова від api** - при використанні цього методу. Якщо ключ може бути вкрадений або втрачений, то при початку роботи в режимі клієнт-сервер (сервер-провайдер сервісу і сервер споживач) програміст або просто власник ключа вже не повинен буде втратити актуальну його версію
###### Недоліки
Потенційна вразливість до **MITM** - описаний метод буде надмірно вразливим до таких атак, проте якщо ми додамо рівні ітеративності (буде описано нижче) і ми будемо використовувати його в контексті https трафіку, він повинен бути цілком стійким.
###### Складності реалізації
Дане рішення може бути досить важко застосовним, оскільки для його використання необхідна низка змін логіки щодо конвенційних систем валідації.


### 2. Оптимізація для реального використання
### 3. Реалізація та застосування на прикладі проекту